---
author:
  name: Linode
  email: docs@linode.com
description: 'A look into Salt''s primary components, features, and configurations for the new SaltStack user'
keywords: ["salt", "automation", "saltstack", "configuration management"]
license: '[CC BY-ND 4.0](https://creativecommons.org/licenses/by-nd/4.0)'
modified: 2018-10-16
modified_by:
  name: Linode
published: 2018-10-16
title: A Beginner's Guide to Salt
external_resources:
 - '[SaltStack Documentation](https://docs.saltstack.com/)'
---

[Salt](https://s.saltstack.com/community/) (also referred to as *SaltStack*) is a Python-based configuration management and orchestration system. Salt uses a master/client model in which a dedicated Salt *master* server manages one or more Salt *minion* servers. Two of Salt's primary jobs are:

-   Remotely executing commands across a set of minions

-   Applying Salt *states* to a set of minions (referred to generally as *configuration management*)

This guide will introduce the core concepts that Salt employs to fulfill these jobs.

## Masters and Minions

The Salt master is a server that acts as a command-and-control center for its minions, and it is where Salt's [remote execution](#remote-execution) commands are run from. For example, this command will report the current disk usage for each of the minions that the master controls:

    salt '*' disk.usage

Many other commands are available. This would install NGINX on the minion named `webserver1`:

    salt 'webserver1' pkg.install nginx

Salt minions are your servers that actually run your applications and services. When using Salt, you should configure and manage your minion servers from the master as much as possible, instead of logging into them directly via SSH or another protocol. Each minion has an ID assigned to it (which can be automatically generated from the minion's hostname), and the Salt master can refer to this ID to [target specific minions](#targeting-minions).

To enable all of these functions, the Salt master server runs a daemon named **salt-master** and the Salt minion servers run a daemon named **salt-minion**.

### Authentication

Communication between the master and minions is performed over the [ZeroMQ](https://docs.saltstack.com/en/latest/topics/development/topology.html) transport protocol, and all communication is encrypted with public/private keypairs. A keypair is generated by a minion when Salt is first installed on it, after which the minion will send its public key to the master. You will need to accept the minion's key from the master, and then communication can proceed between the two.

## Remote Execution

Salt offers a [very wide array](https://docs.saltstack.com/en/latest/ref/modules/all/) of remote *execution modules*. An execution module is a collection of related functions that you can run on your minions **from the master**. For example:

    salt 'webserver1' npm.install gulp

In this command `npm` is [the module](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.npm.html) and `install` is [the function](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.npm.html#salt.modules.npm.install). This command installs the [Gulp](https://gulpjs.com) Node.js package via the Node Package Manager (NPM). Other functions in the `npm` module handle uninstalling packages, listing installed packages, and related tasks.

The execution modules that Salt makes available represent system administration tasks that you would otherwise perform in a shell, including but not limited to:

-   Creating and managing [system users](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.user.html)

-   Installing and uninstalling [software](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.pkg.html)

-   Editing or creating configuration [files](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.file.html#module-salt.modules.file)

{{< note >}}
You can also [write your own](/docs/applications/configuration-management/create-a-salt-execution-module/) execution modules.
{{< /note >}}

### cmd.run

Salt makes available the `cmd.run` function for running arbitrary commands on your minions from the master:

    salt '*' cmd.run 'ls -l /etc'

This would return the contents of `/etc` on each minion.

{{< note >}}
Where possible, it's better to use execution modules than to "shell out" with `cmd.run`.
{{< /note >}}

## States, Formulas, and the Top File

The previous section described how to use remote execution to perform specific actions on a minion. With remote execution, you can set up a minion by entering a series of such commands.

Salt offers another way to configure a minion in which you instead declare the state that a minion *should be in*. This kind of configuration is called a Salt *state*, and the methodology is referred to generally as *configuration management*.

The distinction between the two styles is subtle; for example, here's how installing NGINX is interpreted in each methodology:

-   **Remote execution**: "Install NGINX on the minion"

-   **Configuration management**: "NGINX should be installed on the minion"

Salt states are defined in *state files*. Once you have recorded your states, you then *apply* them to a minion. Salt analyzes the state file and determines what it needs to do to make sure that the minion satisfies the configuration declared by the state. This sometimes results in the same command that would be run via remote execution, but sometimes it doesn't. In the NGINX example, if Salt sees that it's already been installed previously, it won't invoke the package manager when the state is applied.

### Anatomy of a State

Here's an example state file which ensures that: rsync and curl are installed; NGINX is installed; and NGINX is run and enabled to run at boot:

{{< file "/srv/salt/webserver_setup.sls">}}
network_utilities:
  pkg.installed:
    - pkgs:
      - rsync
      - curl

nginx_pkg:
  pkg.installed:
    - name: nginx

nginx_service:
  service.running:
    - name: nginx
    - enable: True
    - require:
      - pkg: nginx_pkg
{{< /file >}}

State files end with the extension `.sls` (**S**a**L**t **S**tate). States files can have one or more *state declarations*, which are the top-level sections of the file (`network_utilities`, `nginx_pkg`, and `nginx_service` in the above example). State declarations IDs are arbitrary, so you can name them however you prefer.

{{< note >}}
If you were to name the ID to be the same as the relevant installed package, then you do not need to specify the `- name` option, as it will be inferred from the ID. For example, this snippet also installs NGINX:

{{< file >}}
nginx:
  pkg.installed
{{< /file >}}

The same name/ID inference convention is true for other Salt modules.
{{< /note >}}

State declarations contain *state modules*. State modules are distinct from execution modules but often perform similar jobs. For example, a `pkg` state module exists with functions analogous to the `pkg` execution module, as with the `pkg.installed` state function and `pkg.install` execution function. As with execution modules, Salt provides a [wide array](https://docs.saltstack.com/en/latest/ref/states/all/) of state modules for you to use.

{{< note >}}
State declarations are not necessarily applied in the order they appear in a state file, but you can specify that a declaration depends on another one using the `require` option. This is the case in the above example; Salt will not attempt to run and enable NGINX until it is installed.
{{< /note >}}

State files are really just collections of dictionaries, lists, strings, and numbers that are then interpreted by Salt. By default, Salt uses the [YAML syntax](https://docs.saltstack.com/en/latest/topics/yaml/) for representing states.

State files are often kept on the Salt master's filesystem, but they can also be stored in [other fileserver locations](https://docs.saltstack.com/en/latest/ref/file_server/backends.html), like a Git repository (in particular, GitHub).

### Applying a State to a Minion

To apply a state to a minion, use the `state.apply` function from the master:

    salt `webserver1` state.apply webserver_setup

This command applies the example `webserver_setup.sls` state to a minion named `webserver1`. When applying the state, the `.sls` suffix is not mentioned.

### Salt Formulas

Formulas are just collections of states that configure an application or system component on a minion. Formulas are usually organized across several different `.sls` files. Splitting a formula's states up across different files can make it easier to organize your work, and state declarations can include and reference declarations across other files.

Formulas that are sufficiently generic are often shared on GitHub to be used by others. The SaltStack organization maintains a [collection of popular formulas](https://github.com/saltstack-formulas). Salt's documentation has [a guide on using a formula](https://docs.saltstack.com/en/latest/topics/development/conventions/formulas.html) hosted on GitHub.

The definition of what constitutes a formula is somewhat loose, and the specific structure of a formula is not mandated by Salt.

### The Top File

In addition to manually applying states to minions, Salt provides a way for you to automatically map which states should be applied to different minions. This map is called the *top file*.





A [Salt state](https://docs.saltstack.com/en/latest/topics/tutorials/starting_states.html) is a particular configuration setup enforced by a `top.sls` file. An SLS file contains YAML data for specific configuration options such as (but not limited to) installed packages, system changes, and application configurations.

One use case for a Salt State is a base system configuration that would include items such as an added third party package repository with an application installed from it, configured as necessary. From this state, a Pillar can be used to add additional information for user credentials, site files, scripts or service files, etc.

Where a state can be templated to provide abstraction over running the same monotonous commands each time, and to make it variable, etc., a [Salt formula](https://docs.saltstack.com/en/latest/topics/development/conventions/formulas.html) is able to provide a group of states all working toward a common configuration or function.

One example of a Salt formula would be an Apache server proxying traffic to NGINX. You could have the initial installation with accompanying packages that may not be direct dependencies, possibly a monitoring service for each web server's service, and potentially a watchdog for configuration changes so as to restart the individual services. A Pillar can then be used to manage the web servers' configuration files.

### Benefits of States and Configuration Management

Defining your configurations in states eases system administration:

-   Setting up states minimizes human error, as you will not need to enter commands one-by-one by hand.

-   Applying a state to minion multiple times generally does not result in any changes beyond the first application. Salt understands when a state has been implemented on a minion and will not perform unnecessary actions.

-   If you update a state file and apply it to a minion, Salt will detect and only apply the changes, which makes updating your systems more efficient.

-   A state can be reused and applied to more than one minion, which will result in identical configurations across different servers.

-   State files can be entered into a version control system, which helps you track changes to your systems over time.

## Grains

[Grains](https://docs.saltstack.com/en/latest/topics/grains/) are individual properties of an operating system or hardware setup such as domain, OS version, CPU core count, etc. Grains allow you to target minons matching specific requirements. For example, the following command installs Apache HTTP Server on all minions running CentOS:

        salt -G 'os:CentOS' pkg.install httpd

Grains are considered to be static and unchanging (such as hardware information), or one-time configurations (such as a machine's domain name). Grains can be assigned to minon configuration files or stored in `/etc/salt/grains`. The built-in grains are those made available by [salt.grains.core](https://docs.saltstack.com/en/latest/ref/grains/all/salt.grains.core.html). You can create custom grains or alter pre-existing ones.


## Pillars

Salt's Pillar feature takes data defined on the Salt master and distributes it to minons. Pillars are especially useful for secure data such as account credentials, defining variables such as network addresses, and minion module configuration. On the other hand, Pillars can be much more complex and Pillar data can be pulled from a multitude of places, such as a Git repository or database. Similar to Salt States, Pillar data is distributed to minions matched in a `top.sls` file.

Using Pillars is optional, but a way to determine appropriate use of a Pillar over a Salt state could be: Data goes into a Pillar, while the logic of how that data should be used makes up a State. Furthermore, sometimes the distinction between Grains and Pillars can be confusing. A Pillar is a structure of application or system data for use by a minion (or multiple minions), whereas Grains are small points of information about the minion, created by, and stored on, the minion.

As an example, if you simply need to change root’s shell to `/bin/zsh`, you could easily just hardcode that right into a State. However, if you’re operating with hundreds of users, you'd want to avoid the process of hardcoding that logic hundreds of times.

## Beacons

The [beacon](https://salt.readthedocs.io/en/stable/topics/beacons/index.html) system is a way of monitoring a variety of system processes on Salt minions. There are a variety of [beacon modules](https://docs.saltstack.com/en/latest/ref/beacons/all/index.html) available.

Beacons can trigger [reactors](https://docs.saltstack.com/en/latest/topics/reactor/index.html#reactor) which can then help implement a change or troubleshoot an issue. For example, if a service's response times out, the reactor system can restart the service.

## Getting Started with Salt

Now that you're familiar with some of Salt's basic terminology and components, move on to our guide [Getting Started with Salt - Basic Installation and Setup](https://www.linode.com/docs/applications/configuration-management/getting-started-with-salt-basic-installation-and-setup/) to set up a configuration to start running commands and provisioning minion servers.

The SaltStack documentation also contains a page of [best practices](https://docs.saltstack.com/en/latest/topics/best_practices.html) to be mindful of when working with Salt. You should review this page and implement those practices into your own workflow whenever possible.